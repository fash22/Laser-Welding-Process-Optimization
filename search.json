[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Optimizing Laser Welded Steel-copper Lap Joints",
    "section": "",
    "text": "Photo by Sergio Rota on Unsplash\n\n\n\nPreface\nWelcome to this article on laser welding and welding cracks. In this comprehensive guide, we will delve into the fascinating world of laser welding, exploring its applications, advantages, and the challenges associated with welding cracks. Laser welding is a cutting-edge process that has revolutionized various industries, enabling precise and efficient joining of materials. However, welding cracks can pose significant risks to the quality and cost-effectiveness of the welding process. Therefore, our objective in this study is to identify the optimal parameters and factors that can minimize welding cracks, ultimately improving product quality and reducing associated costs. By following the CRISP-DM methodology and analyzing the “Screening datasets for laser welded steel-copper lap joints” dataset, we will uncover valuable insights into the relationship between welding process parameters and welding cracks. Join us on this journey as we explore the intricacies of laser welding and discover effective strategies to mitigate welding cracks."
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "1  Introduction",
    "section": "",
    "text": "Laser welding is a process that utilizes a high-powered laser beam to join materials together. It is commonly used in various industries such as automotive, aerospace, and electronics. The purpose of laser welding is to create strong and precise welds with minimal heat input, resulting in reduced distortion and improved overall quality. Compared to traditional welding processes, laser welding offers several advantages including higher welding speeds, smaller heat-affected zones, and the ability to weld dissimilar materials.\nWelding cracks are defects that can occur during the welding process. These cracks can significantly impact the quality and cost of the final product. They can compromise the structural integrity of the weld, leading to potential failures and safety hazards. Additionally, the presence of welding cracks often requires rework or scrap, increasing production costs and causing delays. Therefore, it is crucial to minimize welding cracks to ensure high-quality and cost-effective welding operations.\nThe aim of this project is to reduce the cost of rework and scrap, as well as minimize the risk of customer/market claims related to welding cracks. By identifying the optimal parameters and factors that can minimize welding cracks, businesses can improve their welding processes, enhance product quality, and reduce associated costs.\nThe objective of this study is to find the optimal parameters/factors that can minimize welding cracks in laser welding. It involves identifying the important features that affect welding cracks and understanding the effect of each parameter/factor of the laser welding process on the occurrence of welding cracks.\nIn this project, we will be utilizing the CRoss-Industry Standard Process for Data Mining (CRISP-DM) methodology. CRISP-DM is a widely recognized and proven approach for solving data mining problems. It consists of six phases: Business Understanding, Data Understanding, Data Preparation, Modeling, Evaluation, and Deployment. By following this methodology, we can systematically analyze the data, develop models, and evaluate their effectiveness in addressing the problem statement.\nThe “Screening datasets for laser welded steel-copper lap joints” dataset will be used in this study. This dataset contains various parameters and factors related to laser welding, as well as information on the occurrence of welding cracks. By applying the CRISP-DM methodology to this dataset, we can gain insights into the relationship between the welding process parameters and welding cracks, and ultimately identify the optimal conditions for minimizing welding cracks."
  },
  {
    "objectID": "laser-welding-process.html",
    "href": "laser-welding-process.html",
    "title": "2  Laser Welding Process",
    "section": "",
    "text": "The laser welding process described in the dataset involves joining steel and copper lap joints using a high-powered laser beam. The steel-copper lap joints were prepared by overlapping a steel sheet and a copper sheet, creating a joint area where the laser welding would take place. The dataset includes six factors that were varied during the laser welding process.\nThese factors are:\n\nLaser beam power (W): This refers to the power of the laser beam used in the welding process. It determines the intensity of the laser beam and can affect the depth and quality of the weld.\nWelding speed (m/min): The welding speed refers to the rate at which the laser beam moves along the joint during the welding process. It affects the heat input and the cooling rate, which can influence the formation of welding cracks.\nAngular position in welding direction (°): This factor represents the angular position of the laser beam in relation to the welding direction. It can affect the distribution of heat and the formation of welding cracks.\nFocal position (mm): The focal position refers to the distance between the laser beam focus and the joint surface. It determines the spot size and the energy density of the laser beam, which can impact the weld quality and the occurrence of welding cracks.\nGas flow rate (l/min): The gas flow rate represents the rate at which shielding gas is supplied during the welding process. Shielding gas is used to protect the weld pool from atmospheric contamination. The gas flow rate can influence the cooling rate and the formation of welding cracks.\nMaterial thickness of the steel sheet (mm): This factor represents the thickness of the steel sheet used in the lap joint. The thickness can affect the heat input and the cooling rate, which can influence the formation of welding cracks.\n\nThese factors were chosen based on their potential influence on the occurrence of welding cracks. To create the dataset, 18 parameter combinations were selected, representing different combinations of the six factors. Each parameter combination was repeated five times, resulting in a total of 90 welding experiments. Additionally, each sheet was cut four times to generate a total of 360 cross sections.\nEach line in the dataset represents a cross section that was evaluated for the dimensions of the weld metal. The dataset provides information on the weld depth and the gesometrical dimensions of the weld metal in the laser welded steel-copper lap joints.\nThe Screening datasets for laser welded steel-copper lap joints(see Rinne (2021)) has two versions: V1 and V2. In V1, the dataset includes information on the occurrence of welding cracks, as well as the dimensions of the weld metal. In V2, additional information on the occurrence of partial penetration and the dimensions of the heat-affected zone is included. The V1.1 and V2.1 versions of the dataset were created to address some inconsistencies and errors found in the original versions (V1 and V2). Overall, the dataset provides valuable information on the relationship between the welding process parameters and the occurrence of welding cracks in laser welded steel-copper lap joints. By analyzing this dataset, researchers can gain insights into the optimal conditions for minimizing welding cracks and improving the quality of laser welding operations.\n\n\n\n\nRinne, Jonas. 2021. “Screening Datasets for Laser Welded Steel-Copper Lap Joints.” Mendeley Data. https://doi.org/10.17632/2s5m3crbkd.2."
  },
  {
    "objectID": "project_overview.html#objective",
    "href": "project_overview.html#objective",
    "title": "3  Project Overview",
    "section": "3.1 Objective",
    "text": "3.1 Objective\nThis project is focused on the creation of a machine learning model capable of predicting crack formation in laser-welded steel-copper lap joints. By analyzing various process parameters, the model aims to understand and highlight the correlation between these parameters and the incidence of defects. The ultimate goal is to enhance the welding process, improve joint quality and reliability, and reduce costs associated with rework and scrap in industries utilizing laser welding for steel-copper lap joints."
  },
  {
    "objectID": "project_overview.html#solution-usage",
    "href": "project_overview.html#solution-usage",
    "title": "3  Project Overview",
    "section": "3.2 Solution Usage",
    "text": "3.2 Solution Usage\nThe proposed solution, a predictive machine learning model, will serve as an integral tool in the laser welding industry. The model, once trained and validated, can be incorporated into the manufacturing workflow.\nPrior to welding, the model will ingest process parameters such as laser power, welding speed, and focus position. It will then predict the likelihood of crack formation in the welded joint under these conditions.\nIn case of a high-risk prediction, parameters can be iteratively adjusted and re-evaluated by the model until an acceptable risk level is reached. This facilitates real-time optimization of the welding process, thereby reducing defect occurrence and enhancing product quality.\nFurthermore, the model can aid strategic planning and decision-making by offering insights into how different parameters influence weld quality. This can steer research and development towards more efficient welding techniques and technologies.\nIn essence, this machine learning model is poised to be a valuable asset for operational optimization and strategic planning in industries employing laser welding of steel-copper lap joints."
  },
  {
    "objectID": "project_overview.html#current-solution",
    "href": "project_overview.html#current-solution",
    "title": "3  Project Overview",
    "section": "3.3 Current Solution",
    "text": "3.3 Current Solution\nThe prevention of cracks in laser-welded steel-copper lap joints currently involves understanding the mechanism of solidification cracking and implementing measures to control it (Rinne et al. (2021), Gao et al. (2022)).\nSolidification cracking in welds is a synergistic effect of ε phase liquation, inclusions, and composition segregation (Rinne et al. (2021), Gao et al. (2022)). The welding process can cause grain boundary liquation, reducing cohesion between grains and resistance to intergranular crack propagation (Rinne et al. (2021), Gao et al. (2022)). Composition segregation within grains can induce lattice distortion, reducing the material’s plastic deformation capacity and increasing crack susceptibility (Rinne et al. (2021), Gao et al. (2022)).\nAn oscillating laser has been proposed as an effective solution to inhibit solidification cracking (Rinne et al. (2021), Gao et al. (2022)). Laser oscillating welding promotes grain refinement, solute diffusion, and the formation of uniformly distributed ε-Cu precipitated phases in welds (Rinne et al. (2021), Gao et al. (2022)). This improves intergranular bonding, reduces solidification cracking susceptibility, and increases resistance to plastic deformation (Rinne et al. (2021), Gao et al. (2022)). The tensile strength of joints using laser oscillating welding is 251 MPa, a 35.7% increase compared to 185 MPa using standard laser welding (Rinne et al. (2021), Gao et al. (2022)). The strain of joints using laser oscillating welding is 3.69, a 96% increase compared to 1.88 using standard laser welding (Rinne et al. (2021), Gao et al. (2022)).\nWhile these solutions enhance joint quality and reliability, they require a deep understanding of the welding process and careful parameter control. This is where our machine learning model can add significant value by accurately predicting crack formation based on process parameters and guiding optimization efforts."
  },
  {
    "objectID": "project_overview.html#problem-framing",
    "href": "project_overview.html#problem-framing",
    "title": "3  Project Overview",
    "section": "3.4 Problem Framing",
    "text": "3.4 Problem Framing\nThe problem is structured as a supervised learning task. We have a labeled dataset from Mendeley Data, with known occurrences of cracks in laser-welded steel-copper lap joints (the target variable) for various process parameters (the features). The objective is to train a model on this data to predict the target variable for new, unseen data.\nThe model will undergo offline training, meaning we will use a static dataset for training, and the model will not learn continuously from new data. Once trained and validated, the model can be deployed to predict crack occurrences based on specified input parameters.\nHowever, it’s crucial to acknowledge that while the initial model training is offline, periodic retraining may be required to maintain high predictive performance as welding processes and techniques evolve. This retraining would also be conducted offline, using a new static dataset encompassing the most recent welding data."
  },
  {
    "objectID": "project_overview.html#performance-metric",
    "href": "project_overview.html#performance-metric",
    "title": "3  Project Overview",
    "section": "3.5 Performance Metric",
    "text": "3.5 Performance Metric\nThe model’s performance will be evaluated using the F1 Score, a metric that balances precision and recall. Precision quantifies the proportion of positive identifications that were correct, while recall quantifies the proportion of actual positives correctly identified.\nThe F1 Score is especially useful in scenarios where both false positives and false negatives are present. In this project’s context, a false positive implies a prediction of crack formation where none occurs, and a false negative implies a prediction of no crack formation where one does occur. Both scenarios could have significant implications in the laser welding industry, making it crucial to minimize both, which is what the F1 Score aims to achieve.\nBy employing the F1 Score as our performance metric, we strive to develop a model that not only accurately predicts crack formation but also minimizes both false positives and false negatives."
  },
  {
    "objectID": "project_overview.html#performance-metric-and-business-objectives",
    "href": "project_overview.html#performance-metric-and-business-objectives",
    "title": "3  Project Overview",
    "section": "3.6 Performance Metric and Business Objectives",
    "text": "3.6 Performance Metric and Business Objectives\nThe F1 Score aligns with the business objective of this project, which is to develop a machine learning model capable of accurately predicting crack occurrence in laser-welded steel-copper lap joints based on process parameters. Understanding the relationship between these parameters and crack formation will optimize the welding process, minimize defects, enhance joint quality and reliability, reduce rework and scrap costs, and ultimately improve the bottom line for industries relying on laser welding of steel-copper lap joints.\nThe F1 Score is a measure of model accuracy that balances precision (the proportion of positive identifications that were correct) and recall (the proportion of actual positives correctly identified). This balance ensures the model accurately predicts crack formation while minimizing both false positives (predicting a crack will form when it does not) and false negatives (predicting a crack will not form when it does). Both scenarios could have significant implications in the laser welding industry, making it crucial to minimize both.\nBy employing the F1 Score as our performance metric, we aim to create a model that not only accurately predicts crack formation but also minimizes both false positives and false negatives. This aligns well with our business objective."
  },
  {
    "objectID": "project_overview.html#minimum-performance",
    "href": "project_overview.html#minimum-performance",
    "title": "3  Project Overview",
    "section": "3.7 Minimum Performance",
    "text": "3.7 Minimum Performance\nThe minimum performance required to meet the business objectives would be contingent on the specific needs and constraints of the industries utilizing this model. Generally, a high F1 Score would be desirable, indicating accurate crack prediction while minimizing both false positives and false negatives.\nFor example, an F1 Score of at least 0.85 could serve as a reasonable benchmark. This implies that the model correctly identifies the presence or absence of cracks 85% of the time, maintaining a balance between precision and recall.\nHowever, this is merely a guideline, and actual minimum performance may vary. Factors such as the cost implications of false positives and negatives, the overall impact on production efficiency, and industry standards for quality and reliability would all influence the acceptable performance level.\nThe ultimate objective is to create a model that aids in optimizing the welding process and minimizing defects, thereby enhancing product quality and reducing costs. Therefore, the model’s performance should be sufficiently high to achieve these goals."
  },
  {
    "objectID": "project_overview.html#similar-problems",
    "href": "project_overview.html#similar-problems",
    "title": "3  Project Overview",
    "section": "3.8 Similar Problems",
    "text": "3.8 Similar Problems\nThere are several comparable problems in the field of manufacturing and materials science where machine learning models have been used to predict outcomes based on various parameters. Here are a few examples:\n\nPredicting Welding Distortion: Just like predicting cracks in laser-welded steel-copper lap joints, predicting welding distortion is another problem in the welding industry (Rinne et al. (2021), Gao et al. (2022)). Machine learning models can be trained on various welding parameters and the resulting distortion to predict future distortions based on these parameters (Rinne et al. (2021), Gao et al. (2022)).\nPredicting Material Properties: Machine learning models have been used to predict the properties of materials based on their composition and manufacturing processes (Rinne et al. (2021), Gao et al. (2022)). This is similar to predicting cracks in laser-welded steel-copper lap joints, where the outcome (crack formation) is predicted based on various process parameters (Rinne et al. (2021), Gao et al. (2022)).\nQuality Control in Manufacturing: Machine learning models are often used in quality control applications in various manufacturing industries (Rinne et al. (2021), Gao et al. (2022)). These models can predict the quality of a product based on various factors such as machine settings, environmental conditions, and material properties (Rinne et al. (2021), Gao et al. (2022)).\n\nIn all these cases, the experience and tools used for developing and training the machine learning models can be reused. The process of data preprocessing, feature selection, model training, validation, and testing are common across these problems. Tools and libraries such as Python’s scikit-learn or TensorFlow can be used to develop the machine learning models. Furthermore, techniques for handling imbalanced data, tuning model parameters, and evaluating model performance can also be applied to this problem."
  },
  {
    "objectID": "project_overview.html#human-expertise",
    "href": "project_overview.html#human-expertise",
    "title": "3  Project Overview",
    "section": "3.9 Human Expertise",
    "text": "3.9 Human Expertise\nhuman expertise is available in the field of laser welding and machine learning. Experts in laser welding can provide valuable insights into the welding process, the formation of cracks, and the various parameters that affect weld quality. They can also help in collecting and labeling data for training the machine learning model.\nMachine learning experts, on the other hand, can help in developing and training the model. They can provide guidance on data preprocessing, feature selection, model selection, and hyperparameter tuning. They can also help in evaluating the performance of the model and suggesting improvements.\nCollaboration between these two groups of experts can be highly beneficial for this project. Laser welding experts can provide domain knowledge to guide the development of the machine learning model, while machine learning experts can apply their technical expertise to build a robust and accurate model."
  },
  {
    "objectID": "project_overview.html#methodology",
    "href": "project_overview.html#methodology",
    "title": "3  Project Overview",
    "section": "3.10 Methodology",
    "text": "3.10 Methodology\nTo solve this problem, the following steps would be conducted:\n\nExploratory Data Analysis: This step involves visualizing and summarizing the data to understand its characteristics, distribution, and patterns. It also helps to identify any outliers, missing values, or anomalies in the data.\nData Cleaning & Feature Engineering: This step involves preparing the data for modeling by removing or imputing any missing values, outliers, or noise. It also involves creating new features or transforming existing ones to capture more information from the data and improve the model performance.\nModel Selection: This step involves choosing the most suitable machine learning algorithm for the problem, based on the data type, size, complexity, and desired outcome. Some common algorithms for welding crack detection are convolutional neural networks, support vector machines, and random forests.\nHyper-parameter Tuning: This step involves finding the optimal values for the parameters that control the behavior and performance of the chosen algorithm. This can be done using techniques such as grid search, random search, or Bayesian optimization.\nEnsembling: This step involves combining multiple models to create a more robust and accurate model. This can be done using techniques such as bagging, boosting, or stacking.\nPresentation: This step involves presenting the results and insights from the model to the stakeholders, using appropriate visualizations, metrics, and explanations. It also involves discussing the limitations, challenges, and future directions of the model.\n\n\n\n\n\nGao, Zhongmei, Yuye Yang, Lei Wang, Bin Zhou, and Fei Yan. 2022. “Formation Mechanism and Control of Solidification Cracking in Laser-Welded Joints of Steel/Copper Dissimilar Metals.” Metals 12 (7): 1147. https://doi.org/10.3390/met12071147.\n\n\nRinne, Jonas, Sarah Nothdurft, Jörg Hermsdorf, Stefan Kaierle, and Ludger Overmeyer. 2021. “Investigations on Laser Welding of Dissimilar Joints of Stainless Steel and Copper for Hot Crack Prevention.” Journal of Laser Applications 33: 042042. https://doi.org/10.2351/7.0000489."
  },
  {
    "objectID": "retrieving-data.html#downloading-the-dataset",
    "href": "retrieving-data.html#downloading-the-dataset",
    "title": "4  Retrieving the Dataset",
    "section": "4.1 Downloading the Dataset",
    "text": "4.1 Downloading the Dataset\nTo download the this dataset, the following python function was defined and used.\n\nimport os\nimport urllib.request\nimport zipfile\n\ndef download_file(url, filename):\n    # Check if file already exists in the directory\n    if os.path.exists(f\"datasets/{filename}\"):\n        # Print the directory tree relative to the datasets folder\n        for root, dirs, files in os.walk(\"datasets\"):\n            level = root.replace(\"datasets\", \"\").count(os.sep)\n            indent = \" \" * 4 * (level)\n            print(f\"{indent}{os.path.basename(root)}/\")\n            subindent = \" \" * 4 * (level + 1)\n            for f in files:\n                print(f\"{subindent}{f}\")\n    else:\n        # Download the file from the internet\n        urllib.request.urlretrieve(url, f\"datasets/{filename}\")\n        print(f\"File '{filename}' downloaded successfully.\")\n        \n        # Extract the zip file\n        with zipfile.ZipFile(f\"datasets/{filename}\", 'r') as zip_ref:\n            zip_ref.extractall(\"datasets\")\n        \n        # Print the directory tree relative to the datasets folder\n        for root, dirs, files in os.walk(\"datasets\"):\n            level = root.replace(\"datasets\", \"\").count(os.sep)\n            indent = \" \" * 4 * (level)\n            print(f\"{indent}{os.path.basename(root)}/\")\n            subindent = \" \" * 4 * (level + 1)\n            for f in files:\n                print(f\"{subindent}{f}\")\n\nurl = \"https://prod-dcd-datasets-cache-zipfiles.s3.eu-west-1.amazonaws.com/2s5m3crbkd-2.zip\"\nfilename = \"laser-welding.zip\"\ndownload_file(url, filename)\n\ndatasets/\n    laser-welding.zip\n    V1.csv\n    Screening datasets for laser welded steel-copper lap joints/\n        V1 and V2/\n            Definitive screening steel-copper lap joints V1.xlsx\n            Definitive screening steel-copper lap joints V2.xlsx\n        V1.1 and V2.1/\n            Definitiv screening steel-copper lap joints V1.1.xlsx\n            Definitive screening steel-copper lap joints V2.1.xlsx\n\n\nExplanation:\n\nThe code imports the necessary modules: os for file and directory operations, urllib.request for downloading files from the internet, and zipfile for extracting zip files.\nThe function download_and_extract_file takes two parameters: url (the URL of the file to be downloaded) and filename (the name of the file to be saved in the local directory).\nIt checks if the file already exists in the datasets directory using the os.path.exists function. If it exists, it prints the directory tree relative to the datasets folder using the os.walk function.\nIf the file does not exist, it downloads the file from the internet using urllib.request.urlretrieve and saves it in the datasets directory.\nIt then extracts the zip file using the zipfile.ZipFile context manager and the extractall method, saving the extracted files in the datasets directory.\nFinally, it prints the directory tree relative to the datasets folder using the os.walk function.\n\nThis code allows for downloading and extracting files from the internet, while also checking if the file already exists in the local directory. It provides a convenient way to manage datasets and avoid unnecessary downloads.\n\n\n\n\nRinne, Jonas. 2021. “Screening Datasets for Laser Welded Steel-Copper Lap Joints.” Mendeley Data. https://doi.org/10.17632/2s5m3crbkd.2."
  },
  {
    "objectID": "exploring-data.html#dropping-unwanted-variables",
    "href": "exploring-data.html#dropping-unwanted-variables",
    "title": "5  Data Wrangling",
    "section": "5.1 Dropping Unwanted Variables",
    "text": "5.1 Dropping Unwanted Variables\nBefore wrangling the data, its important to have a deeper understanding of the purpose of each columns. Thus, having known which of these columns were features, targets, and unwanted, would be a great help later during the modelling phase.\n\n5.1.1 Identifying the Feature Variables\nAs highlighted in the Laser Welding Process page, the dataset contains 6 features representing the 6 different factors to be studied. These factors include laser beam power, welding speed, angular position in welding direction, focal position, gas flow rate, and material thickness of the steel sheet. Additionally, there are 2 features for identifying the weld number and cross section position.\n\n5.1.1.1 Factors to be Studied\n\nLaser beam power (W)\nWelding speed (m/min)\nAngular position in welding direction (°)\nFocal position (mm)\nGas flow rate (l/min)\nMaterial thickness of the steel sheet (mm)\n\n\n\n5.1.1.2 Experiment Identification\n\nweld number\ncross section positon in the weld (mm)\n\n\n\n\n5.1.2 Identifying the Target Variables\nThe dataset contains 4 continuous target variables and 1 binary target variable. For this study, we will be focusing on the binary target variable, which indicates the presence or absence of cracking in the weld metal. The remaining 4 continuous target variables will be dropped from our analysis.\n\n5.1.2.1 Binary Target Variable\n\ncracking in the weld metal\n\n\n\n5.1.2.2 Continuous Variables\n\nweld seam width steel (µm)\nweld seam width copper (µm)\nweld depth copper (µm)\ngap\n\nThe python code below categorizes each of the columns of the dataset, and drops the unnecessary columns.\n\nFEATURES = [\n    'power (W)',\n    'welding speed (m/min)',\n    'gas flow rate (l/min)',\n    'focal position (mm)',\n    'angular position (°)',\n    'material thickness (mm)',\n]\n\nEXPERIMENT_ID = [\n    'weld number',\n    'cross section positon in the weld (mm)',\n]\n\nTARGET = [\n    'cracking in the weld metal',\n]\n\nUNNECESSARY_COLS = [\n    'weld seam width steel (µm)',\n    'weld seam width copper (µm)',\n    'weld depth copper (µm)',\n    'gap'\n]\n\n# Drop unnecessary columns\ndataset.drop(UNNECESSARY_COLS,inplace=True,axis=1)\n\n# Check the new dataset\ndataset.head().T\n\n\n\n\n\n\n\n\n0\n1\n2\n3\n4\n\n\n\n\npower (W)\n1050\n1050\n1050\n1050\n1050\n\n\nwelding speed (m/min)\n1.0\n1.0\n1.0\n1.0\n1.0\n\n\ngas flow rate (l/min)\n15\n15\n15\n15\n15\n\n\nfocal position (mm)\n0\n0\n0\n0\n0\n\n\nangular position (°)\n0\n0\n0\n0\n0\n\n\nmaterial thickness (mm)\n0.6\n0.6\n0.6\n0.6\n0.6\n\n\nweld number\n1\n1\n1\n1\n2\n\n\ncross section positon in the weld (mm)\n8\n16\n24\n32\n8\n\n\ncracking in the weld metal\nno\nno\nno\nno\nno"
  },
  {
    "objectID": "exploring-data.html#encoding-categorical-variables",
    "href": "exploring-data.html#encoding-categorical-variables",
    "title": "5  Data Wrangling",
    "section": "5.2 Encoding Categorical Variables",
    "text": "5.2 Encoding Categorical Variables\nBefore feeding the dataset into machine learning models, we need to encode the categorical variable “cracking in the weld metal” into a numeric format. This can be done by mapping “yes” to 1 and “no” to 0.\n\ndataset[\"cracking in the weld metal\"] = dataset[\"cracking in the weld metal\"].map(\n    {\n        \"no\" : 0,\n        \"yes\": 1\n    },\n)\n\ndataset.head().T\n\n\n\n\n\n\n\n\n0\n1\n2\n3\n4\n\n\n\n\npower (W)\n1050.0\n1050.0\n1050.0\n1050.0\n1050.0\n\n\nwelding speed (m/min)\n1.0\n1.0\n1.0\n1.0\n1.0\n\n\ngas flow rate (l/min)\n15.0\n15.0\n15.0\n15.0\n15.0\n\n\nfocal position (mm)\n0.0\n0.0\n0.0\n0.0\n0.0\n\n\nangular position (°)\n0.0\n0.0\n0.0\n0.0\n0.0\n\n\nmaterial thickness (mm)\n0.6\n0.6\n0.6\n0.6\n0.6\n\n\nweld number\n1.0\n1.0\n1.0\n1.0\n2.0\n\n\ncross section positon in the weld (mm)\n8.0\n16.0\n24.0\n32.0\n8.0\n\n\ncracking in the weld metal\n0.0\n0.0\n0.0\n0.0\n0.0"
  },
  {
    "objectID": "exploring-data.html#quantifying-missing-data",
    "href": "exploring-data.html#quantifying-missing-data",
    "title": "5  Data Wrangling",
    "section": "5.3 Quantifying Missing Data",
    "text": "5.3 Quantifying Missing Data\nTo ensure that our machine learning models can be trained effectively, we need to address any missing data. Fortunately, this dataset does not contain any missing data.\n\ndataset.isna().sum()\n\npower (W)                                 0\nwelding speed (m/min)                     0\ngas flow rate (l/min)                     0\nfocal position (mm)                       0\nangular position (°)                      0\nmaterial thickness (mm)                   0\nweld number                               0\ncross section positon in the weld (mm)    0\ncracking in the weld metal                0\ndtype: int64"
  },
  {
    "objectID": "exploring-data.html#data-visualization",
    "href": "exploring-data.html#data-visualization",
    "title": "5  Data Wrangling",
    "section": "5.4 Data Visualization",
    "text": "5.4 Data Visualization\nIn order to gain a deeper understanding of the distribution and relationship of each variable, we will explore the dataset visually.\n\n5.4.1 Data Distribution\nVisualizing the distribution of our data will help us understand its central tendency and spread. This can be achieved using histograms.\n\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\nfor i in range(len(FEATURES)):\n    plt.subplot(3,2,i+1)\n    sns.histplot(dataset[FEATURES[i]])\n\nplt.tight_layout()\n\n\n\n\nHistogram of the 6-parameters to be studied. Based on above plot, only three levels per parameters were gathered.\n\n\n\n\n\nsns.histplot(dataset[TARGET], discrete=True, stat=\"density\");\n\n\n\n\nHistogram of the target variable. Based on above plot, the target variable was highlighly imbalanced – less than 20% of the dataset has a value of 1.\n\n\n\n\n\n\n5.4.2 Correlation Heatmap\nSome machine learning models assume that input features are not correlated. To check for correlations, we will generate a heatmap of the correlation matrix of our input features. This heatmap will also help us identify which features are correlated with the target variable.\n\ncorr_matrix = dataset[FEATURES].corr()\nsns.heatmap(corr_matrix, annot=True, fmt=\".2f\");\n\n\n\n\nHeatmap of the correlation matrix of the feature variables.\n\n\n\n\nBased on the correlation heatmap, we can observe the following:\n\nThere is no multicollinearity among the input features.\nThe features “power,” “angular position,” and “material thickness” are positively correlated with the presence of cracking in the metal weld.\nThe feature “gas flow rate” is negatively correlated with the presence of cracking in the metal weld."
  },
  {
    "objectID": "exploring-data.html#exporting-the-dataset",
    "href": "exploring-data.html#exporting-the-dataset",
    "title": "5  Data Wrangling",
    "section": "5.5 Exporting the Dataset",
    "text": "5.5 Exporting the Dataset\n\ndataset.to_csv(\"datasets/V1.csv\")"
  },
  {
    "objectID": "exploring-data.html#conclusion",
    "href": "exploring-data.html#conclusion",
    "title": "5  Data Wrangling",
    "section": "5.6 Conclusion",
    "text": "5.6 Conclusion\nIn conclusion, we have explored the dataset and identified the relevant features and target variables for our machine learning model. We have also encoded the binary target variable and visualized the data distribution and correlations. The next steps will involve training and evaluating our machine learning models using this prepared dataset."
  },
  {
    "objectID": "modelling.html#importing-relevant-libraries",
    "href": "modelling.html#importing-relevant-libraries",
    "title": "6  Modelling",
    "section": "6.1 Importing Relevant Libraries",
    "text": "6.1 Importing Relevant Libraries\nThe following code contains all the necessary import statements for this section.\n\n# Data Wrangling\nimport numpy as np\nimport pandas as pd\n\n# Data Visualization\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\n# Dataset Splitting\nfrom sklearn.model_selection import train_test_split, cross_validate\n\n# Feature Engineering Classes\nfrom sklearn.compose import ColumnTransformer\nfrom sklearn.pipeline import Pipeline\nfrom sklearn.preprocessing import StandardScaler, MinMaxScaler\n\n# Machine Learning Model Classes\nfrom sklearn.neighbors import KNeighborsClassifier\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.naive_bayes import GaussianNB\nfrom sklearn.svm import SVC\nfrom sklearn.tree import DecisionTreeClassifier\n\n# Classification Metrics\nfrom sklearn.metrics import classification_report\n\n# Classification Visualization\nfrom yellowbrick.classifier import ConfusionMatrix, ClassificationReport, ROCAUC\n\n# Base Classes\nfrom sklearn.base import ClassifierMixin"
  },
  {
    "objectID": "modelling.html#importing-the-dataset",
    "href": "modelling.html#importing-the-dataset",
    "title": "6  Modelling",
    "section": "6.2 Importing the Dataset",
    "text": "6.2 Importing the Dataset\nThe code below loads the pre-processed dataset from the EDA section into a pandas DataFrame.\n\ndataset_uri = \"datasets/V1.csv\"\ndataset = pd.read_csv(dataset_uri, index_col=0)\n\ndataset.head()\n\n\n\n\n\n\n\n\npower (W)\nwelding speed (m/min)\ngas flow rate (l/min)\nfocal position (mm)\nangular position (°)\nmaterial thickness (mm)\nweld number\ncross section positon in the weld (mm)\ncracking in the weld metal\n\n\n\n\n0\n1050\n1.0\n15\n0\n0\n0.6\n1\n8\n0\n\n\n1\n1050\n1.0\n15\n0\n0\n0.6\n1\n16\n0\n\n\n2\n1050\n1.0\n15\n0\n0\n0.6\n1\n24\n0\n\n\n3\n1050\n1.0\n15\n0\n0\n0.6\n1\n32\n0\n\n\n4\n1050\n1.0\n15\n0\n0\n0.6\n2\n8\n0"
  },
  {
    "objectID": "modelling.html#vertical-data-splitting",
    "href": "modelling.html#vertical-data-splitting",
    "title": "6  Modelling",
    "section": "6.3 Vertical Data Splitting",
    "text": "6.3 Vertical Data Splitting\nOnce the dataset is loaded, we will split it into a feature matrix X and a target vector y. X_train and y_train will be soon splitted into X_train & X_cv, and y_train & y_cv during model selection.\n\nX = dataset.iloc[:, :-1].values\ny = dataset.iloc[:, -1].values\n\nX_train, X_test, y_train, y_test = train_test_split(\n    X,\n    y,\n    test_size=0.2,\n    stratify=y,\n    random_state=22\n)"
  },
  {
    "objectID": "modelling.html#horizontal-data-splitting",
    "href": "modelling.html#horizontal-data-splitting",
    "title": "6  Modelling",
    "section": "6.4 Horizontal Data Splitting",
    "text": "6.4 Horizontal Data Splitting\nAfter defining the feature matrix and target vector, we will split them horizontally into a training set and a testing set. The code below performs the horizontal split with a test size of 20%, ensuring that both sets contain the same proportion of 0s and 1s in their target variable."
  },
  {
    "objectID": "modelling.html#training-the-model",
    "href": "modelling.html#training-the-model",
    "title": "6  Modelling",
    "section": "6.5 Training the Model",
    "text": "6.5 Training the Model\nThe code below will train 5 machine learning models using the preprocessed dataset from the Data Wrangling section.\n\nclass ClassifierEvaluator():\n    def __init__(self, estimators: list[ClassifierMixin]) -&gt; None:\n        self.estimators = estimators\n\n    def cross_validate_metrics(self, X, y) -&gt; None:\n        scorings = ['accuracy', 'precision', 'recall', 'f1']\n\n        for estimator in self.estimators:\n            name = type(estimator).__name__\n\n            pipeline = Pipeline(\n                steps=[\n                    (\"std_scaler\", StandardScaler()),\n                    (\"classifier\", estimator)\n                ]\n            )\n\n            metrics = pd.DataFrame(cross_validate(pipeline, X, y, cv=10, scoring=scorings))\n            metrics_viz = sns.stripplot(metrics.iloc[:, 2:]).set(title=name)\n            metrics_viz = sns.violinplot(metrics.iloc[:, 2:], alpha=0.1).set(title=name)\n            plt.ylim([0,1.0])\n            plt.show()\n\n    def tabulate_cross_validation_metrics(self, X, y) -&gt; None:\n        scorings = ['accuracy', 'precision', 'recall', 'f1']\n\n        df = pd.DataFrame()\n\n        for estimator in self.estimators:\n            name = type(estimator).__name__\n\n            pipeline = Pipeline(\n                steps=[\n                    (\"std_scaler\", StandardScaler()),\n                    (\"classifier\", estimator)\n                ]\n            )\n\n            metrics = pd.DataFrame(cross_validate(pipeline, X, y, cv=10, scoring=scorings))\n            metrics[\"Model\"] = name\n            df = pd.concat([df, metrics])\n\n        return df\n\n\nevaluator = ClassifierEvaluator(\n    estimators=[\n        LogisticRegression(),\n        DecisionTreeClassifier(),\n        SVC(),\n        GaussianNB(),\n        KNeighborsClassifier()\n    ],\n)"
  },
  {
    "objectID": "modelling.html#baseline-cross-validation-validation-metrics",
    "href": "modelling.html#baseline-cross-validation-validation-metrics",
    "title": "6  Modelling",
    "section": "6.6 Baseline Cross-validation Validation Metrics",
    "text": "6.6 Baseline Cross-validation Validation Metrics\nThe following series of plots below shows the strip-plot and violin plot of each of the model’s accuracy, f1, recall, and precision rates measured during 10-fold cross validation on the training set.\n\nevaluator.cross_validate_metrics(X_train, y_train)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nUNBAL_results = evaluator.tabulate_cross_validation_metrics(X_train, y_train)\n\n\n6.6.1 Logistic Regression\n\nUNBAL_results[UNBAL_results[\"Model\"] == \"LogisticRegression\"].describe()\n\n\n\n\n\n\n\n\nfit_time\nscore_time\ntest_accuracy\ntest_precision\ntest_recall\ntest_f1\n\n\n\n\ncount\n10.000000\n10.000000\n10.000000\n10.000000\n10.000000\n10.000000\n\n\nmean\n0.003853\n0.007304\n0.941133\n0.891667\n0.700000\n0.762143\n\n\nstd\n0.000756\n0.000479\n0.016264\n0.141912\n0.158114\n0.079090\n\n\nmin\n0.002996\n0.006997\n0.931034\n0.666667\n0.500000\n0.666667\n\n\n25%\n0.003253\n0.007004\n0.931034\n0.750000\n0.562500\n0.687500\n\n\n50%\n0.003996\n0.007009\n0.931034\n1.000000\n0.750000\n0.750000\n\n\n75%\n0.003999\n0.007750\n0.955973\n1.000000\n0.750000\n0.842857\n\n\nmax\n0.005539\n0.008002\n0.965517\n1.000000\n1.000000\n0.857143\n\n\n\n\n\n\n\n\n\n6.6.2 Decision Tree Classifier\n\nUNBAL_results[UNBAL_results[\"Model\"] == \"DecisionTreeClassifier\"].describe()\n\n\n\n\n\n\n\n\nfit_time\nscore_time\ntest_accuracy\ntest_precision\ntest_recall\ntest_f1\n\n\n\n\ncount\n10.000000\n10.000000\n10.000000\n10.000000\n10.000000\n10.000000\n\n\nmean\n0.001800\n0.006414\n0.948276\n0.833333\n0.800000\n0.800476\n\n\nstd\n0.000419\n0.000532\n0.052042\n0.222222\n0.258199\n0.220497\n\n\nmin\n0.001002\n0.006000\n0.862069\n0.500000\n0.250000\n0.333333\n\n\n25%\n0.001989\n0.006002\n0.931034\n0.666667\n0.750000\n0.800000\n\n\n50%\n0.002000\n0.006004\n0.965517\n1.000000\n0.875000\n0.857143\n\n\n75%\n0.002000\n0.006997\n0.991379\n1.000000\n1.000000\n0.964286\n\n\nmax\n0.002001\n0.007120\n1.000000\n1.000000\n1.000000\n1.000000\n\n\n\n\n\n\n\n\n\n6.6.3 Support Vector Classifier\n\nUNBAL_results[UNBAL_results[\"Model\"] == \"SVC\"].describe()\n\n\n\n\n\n\n\n\nfit_time\nscore_time\ntest_accuracy\ntest_precision\ntest_recall\ntest_f1\n\n\n\n\ncount\n10.000000\n10.000000\n10.000000\n10.000000\n10.000000\n10.000000\n\n\nmean\n0.003115\n0.007952\n0.958621\n0.818810\n0.950000\n0.872172\n\n\nstd\n0.000874\n0.000899\n0.042389\n0.172879\n0.105409\n0.128790\n\n\nmin\n0.001999\n0.006992\n0.896552\n0.571429\n0.750000\n0.666667\n\n\n25%\n0.003000\n0.007001\n0.931034\n0.687500\n1.000000\n0.762500\n\n\n50%\n0.003005\n0.008001\n0.965517\n0.800000\n1.000000\n0.888889\n\n\n75%\n0.003103\n0.008880\n1.000000\n1.000000\n1.000000\n1.000000\n\n\nmax\n0.004998\n0.009004\n1.000000\n1.000000\n1.000000\n1.000000\n\n\n\n\n\n\n\n\n\n6.6.4 Gaussian Naive Bayes\n\nUNBAL_results[UNBAL_results[\"Model\"] == \"GaussianNB\"].describe()\n\n\n\n\n\n\n\n\nfit_time\nscore_time\ntest_accuracy\ntest_precision\ntest_recall\ntest_f1\n\n\n\n\ncount\n10.000000\n10.000000\n10.000000\n10.000000\n10.0\n10.000000\n\n\nmean\n0.002001\n0.006600\n0.739655\n0.353948\n1.0\n0.521053\n\n\nstd\n0.000472\n0.000516\n0.054213\n0.049893\n0.0\n0.053877\n\n\nmin\n0.001000\n0.006000\n0.655172\n0.285714\n1.0\n0.444444\n\n\n25%\n0.002000\n0.006001\n0.695813\n0.314103\n1.0\n0.477941\n\n\n50%\n0.002000\n0.006990\n0.741379\n0.348485\n1.0\n0.516667\n\n\n75%\n0.002003\n0.006998\n0.778941\n0.390909\n1.0\n0.561905\n\n\nmax\n0.003002\n0.007012\n0.827586\n0.444444\n1.0\n0.615385\n\n\n\n\n\n\n\n\n\n6.6.5 K-Neighbors Classifier\n\nUNBAL_results[UNBAL_results[\"Model\"] == \"KNeighborsClassifier\"].describe()\n\n\n\n\n\n\n\n\nfit_time\nscore_time\ntest_accuracy\ntest_precision\ntest_recall\ntest_f1\n\n\n\n\ncount\n10.000000\n10.000000\n10.000000\n10.000000\n10.000000\n10.000000\n\n\nmean\n0.001501\n0.008334\n0.955172\n0.829286\n0.925000\n0.861724\n\n\nstd\n0.000528\n0.000474\n0.046120\n0.193911\n0.120761\n0.134958\n\n\nmin\n0.000998\n0.007995\n0.896552\n0.571429\n0.750000\n0.666667\n\n\n25%\n0.001000\n0.007998\n0.905172\n0.637500\n0.812500\n0.732955\n\n\n50%\n0.001501\n0.008000\n0.965517\n0.900000\n1.000000\n0.873016\n\n\n75%\n0.002001\n0.008836\n1.000000\n1.000000\n1.000000\n1.000000\n\n\nmax\n0.002002\n0.009007\n1.000000\n1.000000\n1.000000\n1.000000\n\n\n\n\n\n\n\nBased on the analysis of mean and standard deviation, the models that perform well are LogisticRegression, SVC, and KNeighborsClassifier. These models have relatively high mean accuracy, precision, recall, and F1 score, with low variability (standard deviation). On the other hand, DecisionTreeClassifier and GaussianNB have higher variability and lower mean values, indicating poorer performance.\nIn addition, when comparing the cross validation metrics, it is evident that LogisticRegression, SVC, and KNeighborsClassifier are good models due to their high mean values and low variability."
  },
  {
    "objectID": "class-balance.html#importing-libraries",
    "href": "class-balance.html#importing-libraries",
    "title": "7  Oversampling",
    "section": "7.1 Importing Libraries",
    "text": "7.1 Importing Libraries\nTo begin, we will import the necessary libraries for this section.\n\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\nfrom sklearn.model_selection import train_test_split, cross_validate\n\n# Machine Learning Model Classes\nfrom sklearn.neighbors import KNeighborsClassifier\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.naive_bayes import GaussianNB\nfrom sklearn.svm import SVC\nfrom sklearn.tree import DecisionTreeClassifier\n\n# Pipelines and Transformers\nfrom sklearn.compose import ColumnTransformer\nfrom sklearn.pipeline import Pipeline\nfrom sklearn.preprocessing import StandardScaler, MinMaxScaler\n\nfrom sklearn.base import ClassifierMixin\n\nfrom imblearn.over_sampling import SMOTE, ADASYN"
  },
  {
    "objectID": "class-balance.html#loading-and-splitting-the-dataset",
    "href": "class-balance.html#loading-and-splitting-the-dataset",
    "title": "7  Oversampling",
    "section": "7.2 Loading and Splitting The Dataset",
    "text": "7.2 Loading and Splitting The Dataset\nNext, we will load the dataset into a pandas data frame and split it into a feature matrix and target vector. We will then further split the data into a training set and a testing set. The training set will be used for training and cross validation, while the testing set will be used for model evaluation.\n\ndataset_uri = \"datasets/V1.csv\"\ndataset = pd.read_csv(dataset_uri, index_col=0)\n\nX = dataset.iloc[:, :-1].values\ny = dataset.iloc[:, -1].values\n\nX_train, X_test, y_train, y_test = train_test_split(\n    X,\n    y,\n    test_size=0.2,\n    stratify=y,\n    random_state=22\n)"
  },
  {
    "objectID": "class-balance.html#resampling-minority-class",
    "href": "class-balance.html#resampling-minority-class",
    "title": "7  Oversampling",
    "section": "7.3 Resampling Minority Class",
    "text": "7.3 Resampling Minority Class\nTo address the issue of class imbalance, we will utilize the SMOTE and ADASYN functions from the imblearn library. These techniques will help us oversample the minority class and create a more balanced dataset.\n\nX_train_SMOTE, y_train_SMOTE = SMOTE().fit_resample(X, y)\nX_train_ADASYN, y_train_ADASYN = ADASYN().fit_resample(X, y)"
  },
  {
    "objectID": "class-balance.html#cross-validation-metrics",
    "href": "class-balance.html#cross-validation-metrics",
    "title": "7  Oversampling",
    "section": "7.4 Cross Validation Metrics",
    "text": "7.4 Cross Validation Metrics\n\n7.4.1 Cross Validation Utility Class\nWe will use a utility class that conducts a 10-fold cross validation on the training set using five different machine learning models. This class will help us evaluate the performance of each model.\nNext, we will use the utility class to build a metrics dataframe. This dataframe will contain the results of the 10-fold cross validation for each model, using both the original unbalanced data and the resampled data. We will focus on the f1 score, as it is the key metric highlighted in the project overview. Our goal is to achieve a minimum acceptable f1 score of 0.85.\n\nclass ClassifierEvaluator():\n    def __init__(self, estimators: list[ClassifierMixin]) -&gt; None:\n        self.estimators = estimators\n\n    def cross_validate_metrics(self, X, y) -&gt; None:\n        scorings = ['accuracy', 'precision', 'recall', 'f1']\n\n        for estimator in self.estimators:\n            name = type(estimator).__name__\n\n            pipeline = Pipeline(\n                steps=[\n                    (\"std_scaler\", StandardScaler()),\n                    (\"classifier\", estimator)\n                ]\n            )\n\n            metrics = pd.DataFrame(cross_validate(pipeline, X, y, cv=10, scoring=scorings))\n            metrics_viz = sns.stripplot(metrics.iloc[:, 2:]).set(title=name)\n            metrics_viz = sns.violinplot(metrics.iloc[:, 2:], alpha=0.1).set(title=name)\n            plt.ylim([0,1.0])\n            plt.show()\n\n    def tabulate_cross_validation_metrics(self, X, y) -&gt; None:\n        scorings = ['accuracy', 'precision', 'recall', 'f1']\n\n        df = pd.DataFrame()\n\n        for estimator in self.estimators:\n            name = type(estimator).__name__\n\n            pipeline = Pipeline(\n                steps=[\n                    (\"std_scaler\", StandardScaler()),\n                    (\"classifier\", estimator)\n                ]\n            )\n\n            metrics = pd.DataFrame(cross_validate(pipeline, X, y, cv=10, scoring=scorings))\n            metrics[\"Model\"] = name\n            df = pd.concat([df, metrics])\n\n        return df\n\n# Instanciate the ClassifierEvaluator\nevaluator = ClassifierEvaluator(\n    estimators=[\n        LogisticRegression(),\n        DecisionTreeClassifier(),\n        SVC(),\n        GaussianNB(),\n        KNeighborsClassifier()\n    ],\n)\n\nBased on the metrics, we found that only the KNeighborsClassifier and SVC models surpassed the baseline f1 score of 0.85 by a small margin. However, when using the resampled data, the average f1 score significantly increased. Additionally, the ADASYN data consistently outperformed the SMOTE data.\n\nUNBAL_results = evaluator.tabulate_cross_validation_metrics(X_train, y_train)\nSMOTE_results = evaluator.tabulate_cross_validation_metrics(X_train_SMOTE, y_train_SMOTE)\nADASYN_results = evaluator.tabulate_cross_validation_metrics(X_train_ADASYN, y_train_ADASYN)\n\nUNBAL_results[\"Data\"] = \"UNBAL\"\nSMOTE_results[\"Data\"] = \"SMOTE\"\nADASYN_results[\"Data\"] = \"ADASYN\"\n\ncombined_results = pd.concat([UNBAL_results, SMOTE_results, ADASYN_results])\nmetrics = combined_results.iloc[:, 2:]\n\n\n\n7.4.2 Mean Cross Validation Scores\n\nmetrics.groupby([\"Model\", \"Data\"]).mean()\n\n\n\n\n\n\n\n\n\ntest_accuracy\ntest_precision\ntest_recall\ntest_f1\n\n\nModel\nData\n\n\n\n\n\n\n\n\nDecisionTreeClassifier\nADASYN\n0.917102\n0.911397\n0.971875\n0.931910\n\n\nSMOTE\n0.908065\n0.905505\n0.958065\n0.922635\n\n\nUNBAL\n0.948276\n0.833333\n0.800000\n0.800476\n\n\nGaussianNB\nADASYN\n0.921198\n0.886760\n1.000000\n0.934491\n\n\nSMOTE\n0.854839\n0.825370\n1.000000\n0.892145\n\n\nUNBAL\n0.739655\n0.353948\n1.000000\n0.521053\n\n\nKNeighborsClassifier\nADASYN\n0.950230\n0.928237\n0.996774\n0.957496\n\n\nSMOTE\n0.950000\n0.927398\n0.996774\n0.957118\n\n\nUNBAL\n0.955172\n0.829286\n0.925000\n0.861724\n\n\nLogisticRegression\nADASYN\n0.920097\n0.900423\n1.000000\n0.939324\n\n\nSMOTE\n0.917742\n0.899267\n0.996774\n0.936926\n\n\nUNBAL\n0.941133\n0.891667\n0.700000\n0.762143\n\n\nSVC\nADASYN\n0.951843\n0.928237\n1.000000\n0.959135\n\n\nSMOTE\n0.951613\n0.928831\n0.996774\n0.958150\n\n\nUNBAL\n0.958621\n0.818810\n0.950000\n0.872172\n\n\n\n\n\n\n\nBased on above metrics, only the KNeighborsClassifier and SVC models surpassed the 0.85 baseline f1 score by a small amount. However upon using the resampled data, the average f1 score increases significantly. It was also observed that using the ADASYN data had higher scores than the SMOTE data.\nOverall, the models ability to predict occurrence of welding cracks significantly increased during the use of resampling techniques.\n\n\n7.4.3 Standard Deviation Cross Validation Scores\n\nmetrics.groupby([\"Model\", \"Data\"]).std()\n\n\n\n\n\n\n\n\n\ntest_accuracy\ntest_precision\ntest_recall\ntest_f1\n\n\nModel\nData\n\n\n\n\n\n\n\n\nDecisionTreeClassifier\nADASYN\n0.132454\n0.150921\n0.063276\n0.094462\n\n\nSMOTE\n0.140208\n0.158873\n0.066371\n0.103529\n\n\nUNBAL\n0.052042\n0.222222\n0.258199\n0.220497\n\n\nGaussianNB\nADASYN\n0.105714\n0.138134\n0.000000\n0.083436\n\n\nSMOTE\n0.188709\n0.193569\n0.000000\n0.127962\n\n\nUNBAL\n0.054213\n0.049893\n0.000000\n0.053877\n\n\nKNeighborsClassifier\nADASYN\n0.082962\n0.115160\n0.010201\n0.067072\n\n\nSMOTE\n0.083792\n0.115618\n0.010201\n0.068164\n\n\nUNBAL\n0.046120\n0.193911\n0.120761\n0.134958\n\n\nLogisticRegression\nADASYN\n0.146795\n0.166302\n0.000000\n0.105294\n\n\nSMOTE\n0.148108\n0.168101\n0.010201\n0.106544\n\n\nUNBAL\n0.016264\n0.141912\n0.158114\n0.079090\n\n\nSVC\nADASYN\n0.083841\n0.115160\n0.000000\n0.067975\n\n\nSMOTE\n0.079381\n0.111959\n0.010201\n0.065459\n\n\nUNBAL\n0.042389\n0.172879\n0.105409\n0.128790\n\n\n\n\n\n\n\nAnalyzing the spread of values, we observed that the variability of f1 scores for the SVC, KNeighborsClassifier, and DecisionTree models decreased after using the oversampled data. On the other hand, the variability increased for the LogisticRegression and GaussianNB models.\n\n\n7.4.4 Side-by-side Visualization\nTo provide a visual representation of the metrics, we created a utility function that plots each metric for each model and training set used.\n\ndef compare_metrics(model_name):\n    metric_names = metrics.columns\n    for i in range(4):\n        plt.subplot(2,2,i+1)\n        plt.tight_layout()\n        sns.stripplot(\n            data=metrics[(metrics[\"Model\"] == model_name)],\n            x=\"Data\",\n            y=metric_names[i],\n            hue=\"Data\"\n        )\n        sns.violinplot(\n            data=metrics[(metrics[\"Model\"] == model_name)],\n            x=\"Data\",\n            y=metric_names[i],\n            hue=\"Data\",\n            alpha=0.1\n        )\n        plt.suptitle(f\"{model_name} Cross-validation Metrics on Different Dataset\")\n        plt.xlabel(\"Dataset\")\n        plt.ylim([0,1.0])\n\n\n\n7.4.5 Logistic Regression\n\ncompare_metrics(\"LogisticRegression\")\n\n\n\n\n\n\n7.4.6 Decision Tree Classifier\n\ncompare_metrics(\"DecisionTreeClassifier\")\n\n\n\n\n\n\n7.4.7 Support Vector Classifier\n\ncompare_metrics(\"SVC\")\n\n\n\n\n\n\n7.4.8 Gaussian Naive Bayes\n\ncompare_metrics(\"GaussianNB\")\n\n\n\n\n\n\n7.4.9 K-Neighbors Classifier\n\ncompare_metrics(\"KNeighborsClassifier\")"
  },
  {
    "objectID": "class-balance.html#conclusion",
    "href": "class-balance.html#conclusion",
    "title": "7  Oversampling",
    "section": "7.5 Conclusion",
    "text": "7.5 Conclusion\nIn conclusion, addressing the issue of class imbalance through oversampling techniques resulted in a significant performance boost for our models. The use of the ADASYN resampling technique yielded higher average f1 scores compared to SMOTE. This improvement was achieved without tuning the hyperparameters of the models. Moving forward, we will explore ensembling techniques in the next section to further enhance the predictability of our models."
  },
  {
    "objectID": "summary.html",
    "href": "summary.html",
    "title": "8  Summary",
    "section": "",
    "text": "In summary, this book has no content whatsoever."
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Gao, Zhongmei, Yuye Yang, Lei Wang, Bin Zhou, and Fei Yan. 2022.\n“Formation Mechanism and Control of Solidification Cracking in\nLaser-Welded Joints of Steel/Copper Dissimilar Metals.”\nMetals 12 (7): 1147. https://doi.org/10.3390/met12071147.\n\n\nRinne, Jonas. 2021. “Screening Datasets for Laser Welded\nSteel-Copper Lap Joints.” Mendeley Data. https://doi.org/10.17632/2s5m3crbkd.2.\n\n\nRinne, Jonas, Sarah Nothdurft, Jörg Hermsdorf, Stefan Kaierle, and\nLudger Overmeyer. 2021. “Investigations on Laser Welding of\nDissimilar Joints of Stainless Steel and Copper for Hot Crack\nPrevention.” Journal of Laser Applications 33: 042042.\nhttps://doi.org/10.2351/7.0000489."
  }
]